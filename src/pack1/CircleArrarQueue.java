package pack1;

import java.util.Scanner;

public class CircleArrarQueue {
	public static void main (String[] args) {
		
		//测试数组模拟环形队列的案例
		System.out.println("测试数组模拟环形队列的案例");
		
		
		//创建一个环形队列
		CircleArrar aq= new CircleArrar(4);
				char key = ' ';//接收用户输入
				Scanner scanner = new Scanner(System.in);
				boolean loop = true;
				//输出一个菜单
				while(loop) {
					System.out.println("s(show):显示队列");
					System.out.println("e(exie):退出程序");
					System.out.println("a(add):添加数据到队列");
					System.out.println("g(get):从队列取出程序");
					System.out.println("h(head):查看队列头部数据");
					
					key = scanner.next().charAt(0);//接收一个字符
					switch(key){
					case 's':
						aq.showQueue();
						break;
					case 'a':
						System.out.println("请输入一个数字：");
						int value = scanner.nextInt();
						aq.addQueue(value);
						break;
					case 'g'://取出数据
						try {
							int res =aq.getQueue();
							System.out.printf("取出的数据为：%d\n",res);
						} catch (Exception e) {
							// TODO: handle exception
							System.out.printf(e.getMessage());
						}
						break;
					case 'h':
						try {
							int res = aq.headQueue();
							System.out.printf("队列头的数据为：%d\n",res);
						} catch (Exception e) {
							// TODO: handle exception
							System.out.printf(e.getMessage());
						}
						break;
					case 'e':
						scanner.close();
						loop=false;
						break;
						default:
							break;
					}
					
				}
				System.out.println("程序退出");
		
	}

}

class CircleArrar{
	private int maxSize;//表示数组的最大容量
	//front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素。front的初始值=0
	private int front;
	//rear变量的含义做一个调整；rear指向队列最后一个元素的后一个位置，因为希望空出一个空间作为约定。
	private int rear;
	private int[] arr;//该数组用于存放数据，模拟队列
	
	public CircleArrar(int arrMaxSize) {
		maxSize= arrMaxSize;
		arr = new int [maxSize];
		
	}
	
	//判断队列是否满
		public boolean isFull() {
			return (rear + 1 )%maxSize == front;
		}
		
		//判断队列是否为空
		public boolean isEmpty() {
			return rear == front;
		}
		
		//添加数据到队列
		public void addQueue(int n ) {
			//判断队列是否满
			if(isFull()) {
				System.out.println("队列满，不能加入数据");
				return ;
			}
			//直接将数据加入
			arr[rear] =n;
			//rear后移，这里为了防止数组越界，使用取模方式加一
			rear = (rear +1 )% maxSize;
		}
		
		//出队列,取出数据
		public int getQueue() {
			//判断队列是否为空
			if(isEmpty()) {
				//抛出异常
				throw new RuntimeException("队列空，不能取数据！");
			}
			//这里需要分析出front是指向队列的第一个元素
			//1.先把front对应的值保留在一个临时变量
			//2.将front后移
			//3.将临时保存的变量返回
			int value = arr[front];
			front =( front+1) % maxSize;
			return value;
		}
		
		//显示队列数据
		
		public void showQueue() {
			//遍历
			if(isEmpty()) {
				System.out.println("队列空，没有数据```");
				return ;
			}
			//思路：从front开始遍历，遍历存入队列的所有元素
			for(int i = front;i<front+size();i++) {
				System.out.printf("arr[%d]=%d\n",i % maxSize,arr[i % maxSize]);
				System.out.println();
			}
		}
		
		//求出队列有效数据的个数
		public int size() {
			return (rear + maxSize-front) % maxSize;
		}
		
		//显示队列的头部数据是多少，注意不是取出数据
		public int headQueue() {
			//判断是否为空
			if(isEmpty()) {
				throw new RuntimeException("队列空，没有数据！");
			}
			return arr[front];
			
			
		}
}